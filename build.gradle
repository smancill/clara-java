/*
 * Copyright (c) 2017.  Jefferson Lab (JLab). All rights reserved.
 * Copyright (c) 2020.  SebastiÃ¡n Mancilla
 *
 * Permission to use, copy, modify, and distribute  this software and its
 * documentation for educational, research, and not-for-profit purposes,
 * without fee and without a signed licensing agreement.
 *
 * IN NO EVENT SHALL JLAB BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL
 * INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING
 * OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF JLAB HAS
 * BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * JLAB SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE. THE CLARA SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY,
 * PROVIDED HEREUNDER IS PROVIDED "AS IS". JLAB HAS NO OBLIGATION TO PROVIDE
 * MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 *
 * This software was developed under the United States Government license.
 * For more information contact author at gurjyan@jlab.org
 * Department of Experimental Nuclear Physics, Jefferson Lab.
 */

plugins {
    id 'com.google.protobuf' version '0.8.15' apply false
    id 'com.github.spotbugs' version '4.6.2' apply false
}

allprojects {
    group = 'dev.smancill.clara'
    version = '5.0-SNAPSHOT'

    defaultTasks 'build'
}

ext {
    platformProject = project(':clara-platform')
    subprojectList = subprojects - platformProject
}

//////////////////////////////////////////////////////////////////////////////
// all subprojects
//////////////////////////////////////////////////////////////////////////////

configure(subprojectList) {
    apply plugin: 'java-library'
    apply plugin: 'java-test-fixtures'
    apply plugin: 'groovy'
    apply plugin: 'maven-publish'

    apply plugin: 'checkstyle'
    apply plugin: 'codenarc'
    apply plugin: 'com.github.spotbugs'

    apply plugin: 'eclipse'
    apply plugin: 'idea'

    sourceCompatibility = JavaVersion.VERSION_14
    targetCompatibility = JavaVersion.VERSION_14

    repositories {
        mavenCentral()
    }

    java {
        withSourcesJar()
        withJavadocJar()
    }

    javadoc {
        options.charSet = 'utf8'
        options.encoding = 'utf8'
        options.docEncoding = 'utf8'
    }

    publishing {
        publications {
            maven(MavenPublication) {
                from components.java
            }
        }
    }

    test {
        useJUnitPlatform {
            excludeTags 'integration'
        }
        systemProperty 'spock.configuration', rootProject.file('config/test/SpockConfig.groovy')
        testLogging {
            exceptionFormat = 'full'
        }
    }

    task integrationTest(type: Test) {
        useJUnitPlatform()
        systemProperty 'spock.configuration', rootProject.file('config/test/SpockConfigIntegration.groovy')
        testLogging {
            exceptionFormat = 'full'
        }
        outputs.upToDateWhen { false }
    }

    tasks.withType(GroovyCompile).configureEach {
        options.incremental = true
    }

    task allDeps(type: DependencyReportTask) {}

    task allDepInsight(type: DependencyInsightReportTask) doLast {}
}

//////////////////////////////////////////////////////////////////////////////
// dependencies
//////////////////////////////////////////////////////////////////////////////

project(':clara-platform') {
    apply plugin: 'java-platform'
    apply plugin: 'maven-publish'

    dependencies {
        constraints {
            api project(':clara-core')
            api project(':clara-api')
            api project(':clara-std')
            api project(':clara-shell')
            api project(':clara-examples')
        }
    }

    publishing {
        publications {
            myPlatform(MavenPublication) {
                artifactId = 'clara-bom'
                from components.javaPlatform
            }
        }
    }
}

configure(subprojectList) {
    ext.libs = [
        json: 'org.json:json:20201115',
        snakeyaml: 'org.yaml:snakeyaml:1.28',
        jeromq: 'org.zeromq:jeromq:0.5.2',
        protobuf: 'com.google.protobuf:protobuf-java:3.15.5',
        protoc: 'com.google.protobuf:protoc:3.15.5',
        jline: 'org.jline:jline:3.19.0',
        commons_exec: 'org.apache.commons:commons-exec:1.3',
        freemarker: 'org.freemarker:freemarker:2.3.31',
        jopt: 'net.sf.jopt-simple:jopt-simple:5.0.4',
        jsr305: 'com.google.code.findbugs:jsr305:3.0.2',
    ]

    ext.test_libs = [
        jupiter_api: 'org.junit.jupiter:junit-jupiter-api:5.7.1',
        jupiter_engine: 'org.junit.jupiter:junit-jupiter-engine:5.7.1',
        groovy: 'org.codehaus.groovy:groovy:3.0.7',
        spock: 'org.spockframework:spock-core:2.0-M4-groovy-3.0',
        hamcrest: 'org.hamcrest:hamcrest:2.2',
    ]

    dependencies {
        constraints {
            codenarc(test_libs.groovy)
        }

        api platform(platformProject)

        compileOnly libs.jsr305

        testImplementation test_libs.jupiter_api
        testImplementation test_libs.groovy
        testImplementation test_libs.spock
        testRuntimeOnly test_libs.jupiter_engine
        testImplementation test_libs.hamcrest
    }
}

//////////////////////////////////////////////////////////////////////////////
// subprojects
//////////////////////////////////////////////////////////////////////////////

project(':clara-core') {
    dependencies {
        implementation project(':clara-msg')
        implementation project(':clara-api')

        implementation libs.jopt

        testImplementation testFixtures(project(":clara-msg"))
    }

    javadoc {
        include "org/jlab/clara/sys/**"
        exclude "org/jlab/clara/sys/ccc/**"
        exclude "org/jlab/clara/sys/report/**"
    }
}

project(':clara-msg') {
    apply plugin: 'com.google.protobuf'

    ext {
        generatedProtoDir = "${buildDir.name}/generated/source/proto/main/java"
    }

    dependencies {
        api libs.jeromq
        api libs.protobuf
        implementation libs.jopt
    }

    protobuf {
        protoc {
            artifact = libs.protoc
            if (project.hasProperty('protocPath')) {
                path = protocPath
            }
        }
    }

    sourcesJar {
        from generatedProtoDir
    }

    javadoc {
        exclude "org/jlab/clara/msg/examples/**"
        exclude "org/jlab/clara/msg/net/*Factory.java"
        exclude "org/jlab/clara/msg/sys/*/*.java"
    }

    integrationTest {
        testLogging {
            showStandardStreams = true
            events 'started', 'passed', 'failed'
        }
    }
}

project(':clara-api') {
    dependencies {
        implementation project(':clara-msg')

        api libs.json
        implementation libs.snakeyaml
        implementation libs.jopt

        testImplementation testFixtures(project(":clara-msg"))
    }

    javadoc {
        include "org/jlab/clara/base/**"
        include "org/jlab/clara/engine/**"
        exclude "org/jlab/clara/base/core/**"
    }
}

project(':clara-std') {
    dependencies {
        api project(':clara-api')

        implementation libs.snakeyaml
        implementation libs.commons_exec
        implementation libs.freemarker
        implementation libs.jopt

        testImplementation testFixtures(project(":clara-msg"))
    }

    javadoc {
        include "org/jlab/clara/std/**"
    }
}

project(':clara-shell') {
    dependencies {
        implementation project(':clara-api')
        implementation project(':clara-std')

        api libs.jline
        implementation libs.freemarker

        testImplementation testFixtures(project(":clara-msg"))
    }

    processResources {
        exclude 'lib'
    }
}

project(':clara-examples') {
    dependencies {
        compileOnly project(':clara-api')
        compileOnly project(':clara-std')
    }

    javadoc {
        enabled = false
    }

    javadocJar {
        enabled = false
    }
}

//////////////////////////////////////////////////////////////////////////////
// version information
//////////////////////////////////////////////////////////////////////////////

def runGit(cmd) {
    rootProject.file('.git').exists() ? cmd.execute().text.trim() : ''
}

ext {
    gitBranch = properties['gitBranch'] ?: runGit('git rev-parse --abbrev-ref HEAD')
    gitRev = properties['gitRev'] ?: runGit('git rev-parse --short=10 HEAD')
    gitDescribe = properties['gitDescribe'] ?: runGit('git describe --match=v[0-9]* --abbrev=10 HEAD')
}

configure(subprojectList) {
    task generateVersionProperties {
        def propertiesFile = file("${buildDir}/resources/main/META-INF/version.properties")

        inputs.property 'version', project.version
        inputs.property 'groupId', project.group
        inputs.property 'artifactId', project.archivesBaseName
        inputs.property 'gitBranch', gitBranch
        inputs.property 'gitRev', gitRev
        inputs.property 'gitDescribe', gitDescribe
        outputs.file propertiesFile

        doLast {
            propertiesFile.write "version=${project.version}\n"
            propertiesFile.append "groupId=${project.group}\n"
            propertiesFile.append "artifactId=${project.archivesBaseName}\n"
            propertiesFile.append "builtBy=${System.getProperty('user.name')}\n"
            propertiesFile.append "builtJDK=${System.getProperty('java.version')}\n"

            if (gitBranch) {
                propertiesFile.append "git.branch=${gitBranch}\n"
            }
            if (gitRev) {
                propertiesFile.append "git.revision=${gitRev}\n"
            }
            if (gitDescribe) {
                propertiesFile.append "git.describe=${gitDescribe}\n"
            }
        }
    }

    jar.dependsOn generateVersionProperties
}

//////////////////////////////////////////////////////////////////////////////
// deployment
//////////////////////////////////////////////////////////////////////////////

def deploySpec = copySpec {
    into ('lib') {
        from project(':clara-core').jar
        from project(':clara-core').configurations.runtimeClasspath

        from project(':clara-api').jar
        from project(':clara-api').configurations.runtimeClasspath

        from project(':clara-std').jar
        from project(':clara-std').configurations.runtimeClasspath

        from project(':clara-shell').jar
        from project(':clara-shell').configurations.runtimeClasspath

        from project(':clara-examples').jar
        from project(':clara-examples').configurations.runtimeClasspath

        duplicatesStrategy 'exclude'
    }

    from ('scripts/unix') {
        into 'bin'
        fileMode 0755
    }

    from (project(':clara-shell').file('src/main/resources/lib')) {
        into 'lib/clara'
        fileMode 0755
    }

    // trick Gradle to "create" empy directories
    def tempDir = "${project(':clara-core').buildDir}/distributions/clara_home"

    file("${tempDir}/log").mkdirs()
    file("${tempDir}/plugins").mkdirs()

    from tempDir
}

task distSources(type: Tar) {
    destinationDirectory = file("${project(':clara-core').buildDir}/distributions")
    archiveBaseName = rootProject.name
    archiveVersion = rootProject.version

    archiveExtension = 'tar.gz'
    archiveClassifier = 'src'
    compression = Compression.GZIP

    into "${archiveBaseName.get()}-${archiveVersion.get()}-${archiveClassifier.get()}"

    from 'README.md'
    from 'build.gradle'
    from 'settings.gradle'
    from 'gradlew'
    from 'gradlew.bat'

    def sourceDirs = [
        'config',
        'gradle',
        'scripts',
    ] + subprojectList.collect { "${it.name}/src" }

    sourceDirs.each { dir ->
        from ("${dir}") { into "${dir}" }
    }

    subprojectList.each { dependsOn it.build }
}

task distBinaries(type: Tar) {
    destinationDirectory = file("${project(':clara-core').buildDir}/distributions")
    archiveBaseName = rootProject.name
    archiveVersion = rootProject.version

    archiveExtension = 'tar.gz'
    compression = Compression.GZIP

    into "${archiveBaseName.get()}-${archiveVersion.get()}"
    with deploySpec

    subprojectList.each { dependsOn it.build }
}

task deploy(type: Copy) {
    def dest = "$System.env.CLARA_HOME"

    into dest
    with deploySpec

    doFirst {
        if (dest == 'null') {
            throw new GradleException('CLARA_HOME not set')
        }
    }

    subprojectList.each { dependsOn it.jar }
}

task aggregateJavadoc(type: Javadoc) {
    def projectsWithDocs = subprojectList.findAll { it.javadoc.enabled }

    destinationDir = rootProject.file('doc/javadoc')
    source = projectsWithDocs.collect { it.sourceSets.main.allJava }
    classpath = files(projectsWithDocs.collect { it.sourceSets.main.output })
    classpath += files(projectsWithDocs.collect { it.sourceSets.main.compileClasspath })

    includes = projectsWithDocs.collectMany { it.javadoc.includes }
    excludes = projectsWithDocs.collectMany { it.javadoc.excludes }

    options.charSet = 'utf8'
    options.encoding = 'utf8'
    options.docEncoding = 'utf8'
}

task cleanAggregateJavadoc(type: Delete) {
    delete aggregateJavadoc.outputs
}

//////////////////////////////////////////////////////////////////////////////
// development scripts
//////////////////////////////////////////////////////////////////////////////

configure(subprojectList) {
    ext {
        // used by scripts in `scripts/dev/*` through `scripts/exec-class`
        classPathCache = file("${buildDir}/tmp/classpath")
        testClassPathCache = file("${buildDir}/tmp/test_classpath")
    }

    task cacheClasspath {
        inputs.files sourceSets.main.runtimeClasspath
        inputs.files sourceSets.test.runtimeClasspath
        outputs.files classPathCache
        outputs.files testClassPathCache
        doLast {
            classPathCache.write sourceSets.main.runtimeClasspath.asPath
            testClassPathCache.write sourceSets.test.runtimeClasspath.asPath
        }
    }

    task printClasspath {
        doLast {
            println classPathCache.text.replace(':', '\n')
        }
        dependsOn cacheClasspath
    }

    assemble.dependsOn cacheClasspath
}

//////////////////////////////////////////////////////////////////////////////
// quality check
//////////////////////////////////////////////////////////////////////////////

ext {
    ciMode = properties['ciMode'] ?: 'false'
}

configure(subprojectList) {
    checkstyle {
        toolVersion = '8.41'
        configFile = rootProject.file('config/quality/checkstyle.xml')
        configProperties['samedir'] = rootProject.file('config/quality')
    }

    codenarc {
        toolVersion = '2.0.0'
        ignoreFailures = true
        configFile = rootProject.file('config/quality/codenarc.groovy')
        if (ciMode.toBoolean()) {
            reportFormat 'console'
        }
    }

    spotbugs {
        toolVersion = '4.2.2'
        ignoreFailures = true
        effort = 'max'
        reportLevel = 'medium'
        excludeFilter = rootProject.file('config/quality/findbugs-exclude.xml')
    }

    tasks.withType(com.github.spotbugs.snom.SpotBugsTask) {
        def useXml = ciMode.toBoolean()
        reports {
            xml.enabled = useXml
            html.enabled = !useXml
        }
    }
}

task checkSpotBugsResults {
    doLast {
        def bugsFound = 0
        subprojectList.each { subproject ->
            [subproject.spotbugsMain, subproject.spotbugsTest].each { task ->
                try {
                    bugsFound += printSpotBugs task.reports.getByName('XML').destination
                } catch (FileNotFoundException e) {
                    logger.info e.message
                }
            }
        }
        if (bugsFound > 0) {
            throw new GradleException("$bugsFound SpotBugs rule violations were found.")
        }
    }
}

def printSpotBugs(File xml) {
    def slurped = new XmlSlurper().parse(xml)
    def bugs = slurped.BugInstance
    bugs.each { bug ->
        def line = bug.SourceLine
        logger.error "[SpotBugs] ${line.@sourcepath}:${line.@start}:${line.@end} [${bug.@type}]"
    }
    bugs.size()
}

task codenarc {
    group = 'Verification'
    description = 'Marker task to enable codenarc.'

    subprojectList.each {
        mustRunAfter it.codenarcMain, it.codenarcTest
    }
}

task spotbugs {
    group = 'Verification'
    description = 'Marker task to enable SpotBugs.'

    subprojectList.each {
        mustRunAfter it.spotbugsMain, it.spotbugsTest
    }
    if (ciMode.toBoolean()) {
        finalizedBy checkSpotBugsResults
    }
}

gradle.taskGraph.whenReady { taskGraph ->
    subprojectList.each {
        it.spotbugsMain.onlyIf { taskGraph.hasTask(spotbugs) }
        it.spotbugsTest.onlyIf { taskGraph.hasTask(spotbugs) }
        it.spotbugsTestFixtures.onlyIf { taskGraph.hasTask(spotbugs) }

        it.codenarcMain.onlyIf { taskGraph.hasTask(codenarc) }
        it.codenarcTest.onlyIf { taskGraph.hasTask(codenarc) }
        it.codenarcTestFixtures.onlyIf { taskGraph.hasTask(codenarc) }
    }

    tasks.checkSpotBugsResults.onlyIf {
        taskGraph.hasTask(tasks.spotbugs)
    }

    project(':clara-msg').extractIncludeTestFixturesProto.onlyIf { false }
    project(':clara-msg').extractIncludeTestProto.onlyIf { false }
}

//////////////////////////////////////////////////////////////////////////////
// IDE configuration
//////////////////////////////////////////////////////////////////////////////

configure(subprojectList) {
    eclipse {
        classpath {
            file {
                defaultOutputDir = file("${buildDir.name}/eclipse/default")
                whenMerged { classpath ->
                    classpath.entries.each { source ->
                        if (source.kind == 'src' && source.hasProperty('output')) {
                            source.output = source.output.replace('bin', "${buildDir.name}/eclipse")
                        }
                    }
                }
            }
        }
    }
}

project(':clara-msg') {
    eclipse {
        classpath {
            file {
                whenMerged { classpath ->
                    classpath.entries.add(new org.gradle.plugins.ide.eclipse.model.SourceFolder(generatedProtoDir, null))
                }
                withXml { xml ->
                    xml.asNode().find {
                        it.@kind == 'src' && it.@path == generatedProtoDir
                    }
                    .appendNode('attributes')
                    .appendNode('attribute', [name:'ignore_optional_problems', value:'true'])
                }
            }
        }
    }

    idea {
        module {
            generatedSourceDirs += file(generatedProtoDir)
        }
    }
}

configure(project(':clara-examples')) {
    eclipse {
        classpath {
            plusConfigurations += [configurations.compileClasspath]
        }
    }
}
